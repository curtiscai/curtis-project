# 0 内容提要

## 0.1 主要内容

* 地理坐标系统GCS以及经纬度相关知识。
* GeoHash编码原理以及Base32编码表
* GeoHash编码示例-1位、2位、6位、8位字符串
* GeoHash代码示例以及处理GeoHash的开源项目的使用ch.hsr的geohash。

## 0.2 测试环境

我们使用的geohash处理相关依赖为开源项目（非官方，业务官方）

```xml
<dependency>
		<groupId>ch.hsr</groupId>
		<artifactId>geohash</artifactId>
		<version>1.3.0</version>
</dependency>
```

##  0.3 内容参考

地理坐标系统（Geographic coordinate system）wiki：https://en.wikipedia.org/wiki/Geographic_coordinate_system

Base32编码：https://en.wikipedia.org/wiki/Base32

geohash wiki：https://en.wikipedia.org/wiki/Geohash

geohash开源项目（非官方）：https://github.com/kungfoo/geohash-java

阿里-闲鱼技术：基于快速GeoHash，如何实现海量商品与商圈的高效匹配？https://developer.aliyun.com/article/710273

可视化网格地图：http://geohash.gofreerange.com/

geohash在线编码以及地图可视化：https://www.movable-type.co.uk/scripts/geohash.html

# 1 地理坐标系统  (GCS)

## 1.1 地理坐标系统

​		地理坐标系统（geographic coordinate system）是用于描述地理位置的坐标系统。地理坐标系统使用经度（longitude）、纬度（latitude）和海拔（elevation）组成球面坐标系（spherical coordinate system）。其中经度和纬度表示水平位置，海拔表示垂直位置。

## 1.2 经线与纬线

### 1.2.1 纬线

​		纬线定义为地球表面某点随地球自转所形成的轨迹。任何一根纬线都是圆形而且两两平行。纬线的长度是赤道的周长乘以纬线的纬度的余弦，所以赤道最长，离赤道越远的纬线，周长越短，到了两极就缩为0。从赤道向北和向南，各分90°，称为北纬和南纬，分别用“N”和“S”表示。经度分东西，指南北，纬度分南北，指东西。

### 1.2.2 经线

​		经线也称子午线，定义为地球表面连接南北两极的大圆线上的半圆弧。任意两根经线的长度相等，相交于南北两极点。

## 1.3 经度与纬度

### 1.2.1 纬度（缩写Lat）

​		地球表面上某个点的纬度是该点与地球中心的直线与赤道平面的线面角。连接地球表面相同纬度组成的平面与赤道平行。纬度数值在0至90度之间。位于赤道以北的点的纬度叫北纬，记为N；位于赤道以南的点的纬度称南纬，记为S。北极为90°N；南极为90°S。纬度为0°的平行线称为赤道.**北纬为正数，南纬为负数。**

​		赤道将地球分为北半球和南半球。纬度Lat数值在0至30度之间的地区称为低纬度地区；纬度数值在30至60度之间的地区称为中纬度地区；纬度数值在60至90度之间的地区称为高纬度地区。

### 1.2.2 经度（缩写Lng）

​		地球表面上某个点的经度是指通过该点的经线面与本初子午面所成的二面角。在本初子午线以东的经度叫东经，在本初子午线以西的叫西经。东经用“E”表示，西经用“W”表示。**东经正数，西经为负数**

​		本初子午线的经度是0°，地球上其它地点的经度是向东到180°或向西到180°。不像纬度有赤道作为自然的起点，经度没有自然的起点，做为本初子午线的那条线是人选出来的。在1884年的国际本初子午线大会上格林尼治的子午线被正式定为经度的起点。东经180°即西经180°，约等同于国际换日线，国际换日线的两边，日期相差一日。

​		赤道上经度的每个度大约相当于111km，经度的每个度的距离从0km到111km不等。它的距离随纬度的不同而变化，等于111km乘纬度的余弦。不过这个距离还不是相隔一经度的两点之间最短的距离，最短的距离是连接这两点之间的大圆的弧的距离，它比上面所计算出来的距离要小一些。

### 1.2.3 中国经纬度

​		中国地理位置在北半球，所以纬度范围在0到+90度之间，并且根据纬度从赤道到北极圈依次递增则对于中国来说由南至北纬度由小变大。

​		中国地理位置在本初子午线以东180度以内，根据经度从本初子午线到东经180度依次递增则对于中国来说由西向东经度由小变大。

​		综合以上分析，对于中国来说西南角经纬度均是最小，东北角经纬度均是最大，与笛卡尔坐标系的规律是一致的。

# 2 Geohash概述

## 2.1 Geohash是什么？

​		Geohash是Gustavo Niemeyer于2008年发明的公共领域地理编码系统。Geohash将地理位置编码为由字母和数字组成的短字符串。Geohash将地球表面分割成网格状的桶bucket。

## 2.2 为什么使用Geohash？

* ....
* ....

# 3 Geohash原理

## 3.1 Geohash编码原理

​		GeoHash是一种对地理坐标进行编码的方法，它将二维坐标映射为一个字符串。每个字符串代表一个特定的矩形，在该矩形范围内的所有坐标都共用这个字符串。字符串越长精度越高，对应的矩形范围越小。

​		对一个地理坐标编码时，按照初始区间范围纬度[-90,90]和经度[-180,180]，计算目标经度和纬度分别落在左区间还是右区间。落在左区间则取0，右区间则取1。然后，对上一步得到的区间继续按照此方法对半查找，得到下一位二进制编码。当编码长度达到业务的进度需求后，根据“偶数位放经度，奇数位放纬度”的规则，将得到的二进制编码穿插组合，得到一个新的二进制串。最后，根据base32的对照表，将二进制串翻译成字符串，即得到地理坐标对应的目标GeoHash字符串。

## 3.2 Base32编码表

​		首先应该明白Base32是用于编码而不是加密的。Base32是一种数据编码机制，主要用于将二进制数据编码为可见的字符串，其编码规则是对任意给定的二进制数据，以5位为一组进行切分，对切分的每组二进制数编码得到一个可见字符。Base32使用32位字符集，通常是0-9、a-z中的32个字符，因为0-9、a-z共10+26=36个字符，需要去掉4个字符，对于不同的编码系统去掉的字符不同。

​		Geohash算法使用所有十进制数（0-9）以及去掉字母**“ a”，“ i”，“ l”，“ o”**的其他小写英文字母来作为Base32的编码字符集。Base32的字符映射表如下：

| **Digit**  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **Base32** | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | b    | c    | d    | e    | f    | g    |
| **Digit**  | 16   | 17   | 18   | 19   | 20   | 21   | 22   | 23   | 24   | 25   | 26   | 27   | 28   | 29   | 30   | 31   |
| **Base32** | h    | j    | k    | m    | n    | p    | q    | r    | s    | t    | u    | v    | w    | x    | y    | z    |

# 4 Geohash编码示例及分析

​		我们以北京某地坐标“116.397228,39.909604“为例，计算GeoHash字符串。

首先对经度（116.397228）进行二进制编码，对经度（116.397228）进行20次编码结果为：11010  01011 00010  10111

| 左端点         | 中间值         | 右端点         | 二进制码 | 切分次数            |
| -------------- | -------------- | -------------- | -------- | ------------------- |
| -180.000000    | 0.000000       | 180.000000     | 1        | 2<sup>1 </sup> = 2  |
| 0.000000       | 90.000000      | 180.000000     | 1        | 2<sup>2</sup> = 4   |
| 90.000000      | 135.000000     | 180.000000     | 0        | 2<sup>3</sup> = 8   |
| 90.000000      | 112.500000     | 135.000000     | 1        | 2<sup>4</sup> = 16  |
| 112.500000     | 123.750000     | 135.000000     | 0        | 2<sup>5</sup> = 32  |
| 112.500000     | 118.125000     | 123.750000     | 0        | 2<sup>6</sup> = 64  |
| 112.500000     | 115.312500     | 118.125000     | 1        | 2<sup>7</sup> = 128 |
| 115.312500     | 116.718750     | 118.125000     | 0        | 2<sup>8</sup>       |
| 115.312500     | 116.015625     | 116.718750     | 1        | 2<sup>9</sup>       |
| 116.015625     | 116.3671875    | 116.718750     | 1        | 2<sup>10</sup>      |
| 116.3671875    | 116.54296875   | 116.718750     | 0        | 2<sup>11</sup>      |
| 116.3671875    | 116.455078125  | 116.54296875   | 0        | 2<sup>12</sup>      |
| 116.3671875    | 116.4111328125 | 116.455078125  | 0        | 2<sup>13</sup>      |
| 116.3671875    | 116.3891601563 | 116.4111328125 | 1        | 2<sup>14</sup>      |
| 116.3891601563 | 116.4001464844 | 116.4111328125 | 0        | 2<sup>15</sup>      |
| 116.3891601563 | 116.3946533204 | 116.4001464844 | 1        | 2<sup>16</sup>      |
| 116.3946533204 | 116.3973999024 | 116.4001464844 | 0        | 2<sup>17</sup>      |
| 116.3946533204 | 116.3960266114 | 116.3973999024 | 1        | 2<sup>18</sup>      |
| 116.3960266114 | 116.3967132569 | 116.3973999024 | 1        | 2<sup>19</sup>      |
| 116.3967132569 | 116.3970565797 | 116.3973999024 | 1        | 2<sup>20</sup>      |

其次对纬度（39.909604）进行二进制编码，对纬度（39.909604）进行20次编码结果为：10111  00011 00001  01010

| 左端点        | 中间值        | 右端点        | 二进制码 | 切分次数            |
| ------------- | ------------- | ------------- | -------- | ------------------- |
| -90.000000    | 0.000000      | 90.000000     | 1        | 2<sup>1 </sup> = 2  |
| 0.000000      | 45.000000     | 90.000000     | 0        | 2<sup>2</sup> = 4   |
| 0.000000      | 22.500000     | 45.000000     | 1        | 2<sup>3</sup> = 8   |
| 22.500000     | 33.750000     | 45.000000     | 1        | 2<sup>4</sup> = 16  |
| 33.750000     | 39.375000     | 45.000000     | 1        | 2<sup>5</sup> = 32  |
| 39.375000     | 42.187500     | 45.000000     | 0        | 2<sup>6</sup> = 64  |
| 39.375000     | 40.781250     | 42.187500     | 0        | 2<sup>7</sup> = 128 |
| 39.375000     | 40.078125     | 40.781250     | 0        | 2<sup>8</sup>       |
| 39.375000     | 39.7265625    | 40.078125     | 1        | 2<sup>9</sup>       |
| 39.7265625    | 39.90234375   | 40.078125     | 1        | 2<sup>10</sup>      |
| 39.90234375   | 39.990234375  | 40.078125     | 0        | 2<sup>11</sup>      |
| 39.90234375   | 39.9462890625 | 39.990234375  | 0        | 2<sup>12</sup>      |
| 39.90234375   | 39.9243164063 | 39.9462890625 | 0        | 2<sup>13</sup>      |
| 39.90234375   | 39.9133300781 | 39.9243164063 | 0        | 2<sup>14</sup>      |
| 39.90234375   | 39.9078369141 | 39.9133300781 | 1        | 2<sup>15</sup>      |
| 39.9078369141 | 39.9105834961 | 39.9133300781 | 0        | 2<sup>16</sup>      |
| 39.9078369141 | 39.9092102051 | 39.9105834961 | 1        | 2<sup>17</sup>      |
| 39.9092102051 | 39.9098968506 | 39.9105834961 | 0        | 2<sup>18</sup>      |
| 39.9092102051 | 39.9095535279 | 39.9098968506 | 1        | 2<sup>19</sup>      |
| 39.9095535279 | 39.9097251892 | 39.9098968506 | 0        | 2<sup>20</sup>      |

我们再看下结果，

经度（116.397228）进行20次编码结果为：11010  01011 00010  10111

纬度（39.909604）  进行20次编码结果为：10111  00011 00001  01010

我们按照**偶数位放经度，奇数位放纬度或者说先经度后纬度**穿插，将经纬度的二进制码进行穿插得到：

11100  11101  00100  01111  00000 01001  10011  00010

11100  11101  00100  01111  00000  01001  10011  00000000000000000000000000000



​		首先回答一个问题，为什么经度切分比纬度切分次数多一次，得到的网格还是近似正方形呢？这是因为经度范围-180到180，而纬度是-90到90，经度切分一次后就是-180到0和0到180，是180度就和纬度的-90到90的180度相同了，这是从度的角度分析，不是很准确，我们再从长度来分析，如果地球是标准的球体，那么赤道上纬线周长是2πr，而经线的长度是周长的一半，正好是πr，也就是说如果地球是标准球体，那么经线上每一度和纬线上相同意义上的一度的长度是相同的，可以从公式2πr/360=πr/180来看出这点。

## 4.1 GeoHash-1位字符串示例

### 4.1.1 GeoHash-1位字符串分析

​		GeoHash使用base32编码，1位GeoHash字符串需要使用5位二进制数，也就是1位GeoHash只需要**经纬经纬经**，也就是3次经度切分和2次纬度切分。接下来我们重新对经纬度进行编码：

​		经度（116.397228）进行3次二进制编码：110

| 左端点      | 中间值     | 右端点     | 二进制码 | 切分次数           |
| ----------- | ---------- | ---------- | -------- | ------------------ |
| -180.000000 | 0.000000   | 180.000000 | 1        | 2<sup>1 </sup> = 2 |
| 0.000000    | 90.000000  | 180.000000 | 1        | 2<sup>2</sup> = 4  |
| 90.000000   | 135.000000 | 180.000000 | 0        | 2<sup>3</sup> = 8  |

​		纬度（39.909604）进行2次二进制编码：10

| 左端点     | 中间值    | 右端点    | 二进制码 | 切分次数           |
| ---------- | --------- | --------- | -------- | ------------------ |
| -90.000000 | 0.000000  | 90.000000 | 1        | 2<sup>1 </sup> = 2 |
| 0.000000   | 45.000000 | 90.000000 | 0        | 2<sup>2</sup> = 4  |

​		我们按照**偶数位放经度，奇数位放纬度或者说先经度后纬度**穿插，将经纬度的二进制码进行穿插得到：11100，换算成十进制数是28，查看Geohash的base32编码表，十进制数28对应的base32字符是w，也就是说对该点进行GeoHash得到的1位GeoHash字符串为w。

### 4.1.2 GeoHash-1位字符串代码示例

```java
GeoHash geoHash1 = GeoHash.withCharacterPrecision(lat, lng, 1);
// (22.5,112.5)
System.out.println(geoHash1.getBoundingBox().getCenterPoint());
// (45.0,90.0) -> (0.0,135.0)
System.out.println(geoHash1.getBoundingBox());
// w
System.out.println(geoHash1.toBase32());
// 1110000000000000000000000000000000000000000000000000000000000000 -> (45.0,90.0) -> (0.0,135.0) -> w
System.out.println(geoHash1);
```

## 4.2 GeoHash-2位字符串示例

### 4.2.1 GeoHash-2位字符串分析

​		GeoHash使用base32编码，2位GeoHash字符串需要使用10位二进制数，也就是1位GeoHash需要**经纬经纬经纬经纬经纬**，也就是5次经度切分和5次纬度切分。接下来我们重新对经纬度进行编码：

​		经度（116.397228）进行3次二进制编码：11010

| 左端点      | 中间值     | 右端点     | 二进制码 | 切分次数           |
| ----------- | ---------- | ---------- | -------- | ------------------ |
| -180.000000 | 0.000000   | 180.000000 | 1        | 2<sup>1 </sup> = 2 |
| 0.000000    | 90.000000  | 180.000000 | 1        | 2<sup>2</sup> = 4  |
| 90.000000   | 135.000000 | 180.000000 | 0        | 2<sup>3</sup> = 8  |
| 90.000000   | 112.500000 | 135.000000 | 1        | 2<sup>4</sup> = 16 |
| 112.500000  | 123.750000 | 135.000000 | 0        | 2<sup>5</sup> = 32 |

​		纬度（39.909604）进行2次二进制编码：10111

| 左端点     | 中间值    | 右端点    | 二进制码 | 切分次数           |
| ---------- | --------- | --------- | -------- | ------------------ |
| -90.000000 | 0.000000  | 90.000000 | 1        | 2<sup>1 </sup> = 2 |
| 0.000000   | 45.000000 | 90.000000 | 0        | 2<sup>2</sup> = 4  |
| 0.000000   | 22.500000 | 45.000000 | 1        | 2<sup>3</sup> = 8  |
| 22.500000  | 33.750000 | 45.000000 | 1        | 2<sup>4</sup> = 16 |
| 33.750000  | 39.375000 | 45.000000 | 1        | 2<sup>5</sup> = 32 |

​		我们按照**偶数位放经度，奇数位放纬度或者说先经度后纬度**穿插，将经纬度的二进制码进行穿插得到：11100  11101，每五位换算成一个十进制数是28 29，查看Geohash的base32编码表，十进制数28对应的base32字符是w，十进制数29对应的base32字符是x，也就是说对该点进行GeoHash得到的2位GeoHash字符串为wx。

### 4.2.2 GeoHash-2位字符串代码示例

```java
GeoHash geoHash2 = GeoHash.withCharacterPrecision(lat, lng, 2);
// (42.1875,118.125)
System.out.println(geoHash2.getBoundingBox().getCenterPoint());
// (45.0,112.5) -> (39.375,123.75)
System.out.println(geoHash2.getBoundingBox());
// wx
System.out.println(geoHash2.toBase32());
// 1110011101000000000000000000000000000000000000000000000000000000 -> (45.0,112.5) -> (39.375,123.75) -> wx
System.out.println(geoHash2);
```

## 4.3 GeoHash-6位字符串示例

### 4.3.1 GeoHash-6位字符串分析

​		GeoHash使用base32编码，6位GeoHash字符串需要使用30位二进制数，也就是6位GeoHash需要15次经度切分和15次纬度切分。接下来我们重新对经纬度进行编码：

​		首先对经度（116.397228）进行二进制编码，对经度（116.397228）进行15次编码结果为：11010  01011 00010

| 左端点         | 中间值         | 右端点         | 二进制码 | 切分次数            |
| -------------- | -------------- | -------------- | -------- | ------------------- |
| -180.000000    | 0.000000       | 180.000000     | 1        | 2<sup>1 </sup> = 2  |
| 0.000000       | 90.000000      | 180.000000     | 1        | 2<sup>2</sup> = 4   |
| 90.000000      | 135.000000     | 180.000000     | 0        | 2<sup>3</sup> = 8   |
| 90.000000      | 112.500000     | 135.000000     | 1        | 2<sup>4</sup> = 16  |
| 112.500000     | 123.750000     | 135.000000     | 0        | 2<sup>5</sup> = 32  |
| 112.500000     | 118.125000     | 123.750000     | 0        | 2<sup>6</sup> = 64  |
| 112.500000     | 115.312500     | 118.125000     | 1        | 2<sup>7</sup> = 128 |
| 115.312500     | 116.718750     | 118.125000     | 0        | 2<sup>8</sup>       |
| 115.312500     | 116.015625     | 116.718750     | 1        | 2<sup>9</sup>       |
| 116.015625     | 116.3671875    | 116.718750     | 1        | 2<sup>10</sup>      |
| 116.3671875    | 116.54296875   | 116.718750     | 0        | 2<sup>11</sup>      |
| 116.3671875    | 116.455078125  | 116.54296875   | 0        | 2<sup>12</sup>      |
| 116.3671875    | 116.4111328125 | 116.455078125  | 0        | 2<sup>13</sup>      |
| 116.3671875    | 116.3891601563 | 116.4111328125 | 1        | 2<sup>14</sup>      |
| 116.3891601563 | 116.4001464844 | 116.4111328125 | 0        | 2<sup>15</sup>      |

​		其次对纬度（39.909604）进行二进制编码，对纬度（39.909604）进行15次编码结果为：10111  00011 00001

| 左端点      | 中间值        | 右端点        | 二进制码 | 切分次数            |
| ----------- | ------------- | ------------- | -------- | ------------------- |
| -90.000000  | 0.000000      | 90.000000     | 1        | 2<sup>1 </sup> = 2  |
| 0.000000    | 45.000000     | 90.000000     | 0        | 2<sup>2</sup> = 4   |
| 0.000000    | 22.500000     | 45.000000     | 1        | 2<sup>3</sup> = 8   |
| 22.500000   | 33.750000     | 45.000000     | 1        | 2<sup>4</sup> = 16  |
| 33.750000   | 39.375000     | 45.000000     | 1        | 2<sup>5</sup> = 32  |
| 39.375000   | 42.187500     | 45.000000     | 0        | 2<sup>6</sup> = 64  |
| 39.375000   | 40.781250     | 42.187500     | 0        | 2<sup>7</sup> = 128 |
| 39.375000   | 40.078125     | 40.781250     | 0        | 2<sup>8</sup>       |
| 39.375000   | 39.7265625    | 40.078125     | 1        | 2<sup>9</sup>       |
| 39.7265625  | 39.90234375   | 40.078125     | 1        | 2<sup>10</sup>      |
| 39.90234375 | 39.990234375  | 40.078125     | 0        | 2<sup>11</sup>      |
| 39.90234375 | 39.9462890625 | 39.990234375  | 0        | 2<sup>12</sup>      |
| 39.90234375 | 39.9243164063 | 39.9462890625 | 0        | 2<sup>13</sup>      |
| 39.90234375 | 39.9133300781 | 39.9243164063 | 0        | 2<sup>14</sup>      |
| 39.90234375 | 39.9078369141 | 39.9133300781 | 1        | 2<sup>15</sup>      |

我们再看下结果，

经度（116.397228）进行15次编码结果为：11010  01011 00010

纬度（39.909604）  进行15次编码结果为：10111  00011 00001

我们按照**偶数位放经度，奇数位放纬度或者说先经度后纬度**穿插，将经纬度的二进制码进行穿插得到：

11100  11101  00100  01111  00000   01001

11100  11101  00100  01111  00000   01001  0000000000000000000000000000000000

每五位换算成一个十进制数是28 29 4 15 0 9，查看Geohash的base32编码表，十进制数28对应的base32字符是w，十进制数29对应的base32字符是x，十进制数4对应的base32字符是4，十进制数15对应的base32字符是g，十进制数0对应的base32字符是0，十进制数9对应的base32字符是9，也就是说对该点进行GeoHash得到的6位GeoHash字符串为wx4g09。

### 4.3.2 GeoHash-6位字符串代码示例

```java
GeoHash geoHash6 = GeoHash.withCharacterPrecision(lat, lng, 6);
// (39.91058349609375,116.3946533203125)
System.out.println(geoHash6.getBoundingBox().getCenterPoint());
// (39.913330078125,116.38916015625) -> (39.9078369140625,116.400146484375)
System.out.println(geoHash6.getBoundingBox());
// wx4g09
System.out.println(geoHash6.toBase32());
// 1110011101001000111100000010010000000000000000000000000000000000 -> (39.913330078125,116.38916015625) -> (39.9078369140625,116.400146484375) -> wx4g09
System.out.println(geoHash6);
```

## 4.4 GeoHash-7位字符串示例

### 4.4.1 GeoHash-7位字符串分析

​		GeoHash使用base32编码，7位GeoHash字符串需要使用35位二进制数，也就是7位GeoHash需要18次经度切分和17次纬度切分。接下来我们重新对经纬度进行编码：

​		首先对经度（116.397228）进行二进制编码，对经度（116.397228）进行18次编码结果为：11010  01011 00010  101

| 左端点         | 中间值         | 右端点         | 二进制码 | 切分次数            |
| -------------- | -------------- | -------------- | -------- | ------------------- |
| -180.000000    | 0.000000       | 180.000000     | 1        | 2<sup>1 </sup> = 2  |
| 0.000000       | 90.000000      | 180.000000     | 1        | 2<sup>2</sup> = 4   |
| 90.000000      | 135.000000     | 180.000000     | 0        | 2<sup>3</sup> = 8   |
| 90.000000      | 112.500000     | 135.000000     | 1        | 2<sup>4</sup> = 16  |
| 112.500000     | 123.750000     | 135.000000     | 0        | 2<sup>5</sup> = 32  |
| 112.500000     | 118.125000     | 123.750000     | 0        | 2<sup>6</sup> = 64  |
| 112.500000     | 115.312500     | 118.125000     | 1        | 2<sup>7</sup> = 128 |
| 115.312500     | 116.718750     | 118.125000     | 0        | 2<sup>8</sup>       |
| 115.312500     | 116.015625     | 116.718750     | 1        | 2<sup>9</sup>       |
| 116.015625     | 116.3671875    | 116.718750     | 1        | 2<sup>10</sup>      |
| 116.3671875    | 116.54296875   | 116.718750     | 0        | 2<sup>11</sup>      |
| 116.3671875    | 116.455078125  | 116.54296875   | 0        | 2<sup>12</sup>      |
| 116.3671875    | 116.4111328125 | 116.455078125  | 0        | 2<sup>13</sup>      |
| 116.3671875    | 116.3891601563 | 116.4111328125 | 1        | 2<sup>14</sup>      |
| 116.3891601563 | 116.4001464844 | 116.4111328125 | 0        | 2<sup>15</sup>      |
| 116.3891601563 | 116.3946533204 | 116.4001464844 | 1        | 2<sup>16</sup>      |
| 116.3946533204 | 116.3973999024 | 116.4001464844 | 0        | 2<sup>17</sup>      |
| 116.3946533204 | 116.3960266114 | 116.3973999024 | 1        | 2<sup>18</sup>      |

​		其次对纬度（39.909604）进行二进制编码，对纬度（39.909604）进行17次编码结果为：10111  00011 00001  01

| 左端点        | 中间值        | 右端点        | 二进制码 | 切分次数            |
| ------------- | ------------- | ------------- | -------- | ------------------- |
| -90.000000    | 0.000000      | 90.000000     | 1        | 2<sup>1 </sup> = 2  |
| 0.000000      | 45.000000     | 90.000000     | 0        | 2<sup>2</sup> = 4   |
| 0.000000      | 22.500000     | 45.000000     | 1        | 2<sup>3</sup> = 8   |
| 22.500000     | 33.750000     | 45.000000     | 1        | 2<sup>4</sup> = 16  |
| 33.750000     | 39.375000     | 45.000000     | 1        | 2<sup>5</sup> = 32  |
| 39.375000     | 42.187500     | 45.000000     | 0        | 2<sup>6</sup> = 64  |
| 39.375000     | 40.781250     | 42.187500     | 0        | 2<sup>7</sup> = 128 |
| 39.375000     | 40.078125     | 40.781250     | 0        | 2<sup>8</sup>       |
| 39.375000     | 39.7265625    | 40.078125     | 1        | 2<sup>9</sup>       |
| 39.7265625    | 39.90234375   | 40.078125     | 1        | 2<sup>10</sup>      |
| 39.90234375   | 39.990234375  | 40.078125     | 0        | 2<sup>11</sup>      |
| 39.90234375   | 39.9462890625 | 39.990234375  | 0        | 2<sup>12</sup>      |
| 39.90234375   | 39.9243164063 | 39.9462890625 | 0        | 2<sup>13</sup>      |
| 39.90234375   | 39.9133300781 | 39.9243164063 | 0        | 2<sup>14</sup>      |
| 39.90234375   | 39.9078369141 | 39.9133300781 | 1        | 2<sup>15</sup>      |
| 39.9078369141 | 39.9105834961 | 39.9133300781 | 0        | 2<sup>16</sup>      |
| 39.9078369141 | 39.9092102051 | 39.9105834961 | 1        | 2<sup>17</sup>      |

我们再看下结果，

经度（116.397228）进行18次编码结果为：11010  01011 00010  101

纬度（39.909604）  进行17次编码结果为：10111  00011 00001  01

我们按照**偶数位放经度，奇数位放纬度或者说先经度后纬度**穿插，将经纬度的二进制码进行穿插得到：

11100  11101  00100  01111  00000  01001  10011

11100  11101  00100  01111  00000  01001  10011  00000000000000000000000000000

### 4.4.2 GeoHash-7位字符串代码示例

```java
GeoHash geoHash7 = GeoHash.withCharacterPrecision(lat, lng, 7);
// (39.90989685058594,116.39671325683594)
System.out.println(geoHash7.getBoundingBox().getCenterPoint());
// (39.91058349609375,116.39602661132812) -> (39.909210205078125,116.39739990234375)
System.out.println(geoHash7.getBoundingBox());
// wx4g09m
System.out.println(geoHash7.toBase32());
// 1110011101001000111100000010011001100000000000000000000000000000 -> (39.91058349609375,116.39602661132812) -> (39.909210205078125,116.39739990234375) -> wx4g09m
System.out.println(geoHash7);
```

# 5 Geohash开源项目使用示例

## 5.1 构建GeoHash对象几种方式

```java
/**
 * 构造GeoHash的几种方式：使用GeoHash字符串、使用经纬度以及字符个数、使用经纬度以及任意位
 */
@Test
public void testConstructGeoHash() {
		// 使用GeoHash字符串构造GeoHash对象
		GeoHash geoHash61 = GeoHash.fromGeohashString("wx4g09");
		// geoHash61: 1110011101001000111100000010010000000000000000000000000000000000 ->
		// (39.913330078125,116.38916015625) -> (39.9078369140625,116.400146484375) -> wx4g09
		System.out.println("geoHash61: " + geoHash61);
		GeoHash geoHash71 = GeoHash.fromGeohashString("wx4g09m");
		// geoHash71: 1110011101001000111100000010011001100000000000000000000000000000 ->
		// (39.91058349609375,116.39602661132812) -> (39.909210205078125,116.39739990234375) -> wx4g09m
		System.out.println("geoHash71: " + geoHash71);

		// 使用经度、纬度以及字符个数来构建GeoHash
		GeoHash geoHash62 = GeoHash.withCharacterPrecision(39.909604, 116.397228, 6);
		// geoHash62: 1110011101001000111100000010010000000000000000000000000000000000 ->
		// (39.913330078125,116.38916015625) -> (39.9078369140625,116.400146484375) -> wx4g09
		System.out.println("geoHash62: " + geoHash62);
		GeoHash geoHash72 = GeoHash.withCharacterPrecision(39.909604, 116.397228, 7);
		// geoHash72: 1110011101001000111100000010011001100000000000000000000000000000 ->
		// (39.91058349609375,116.39602661132812) -> (39.909210205078125,116.39739990234375) -> wx4g09m
		System.out.println("geoHash72: " + geoHash72);

		// 可以使用经度、纬度以及任意位来构建GeoHash，只有5的整数位才可以使用Base32编码为GeoHash字符串
		GeoHash geoHashBit1 = GeoHash.withBitPrecision(39.909604, 116.397228, 6);
		// geoHashBit1: 1110010000000000000000000000000000000000000000000000000000000000 ->
		// (45.0,90.0) -> (22.5,135.0), bits: 6
		System.out.println("geoHashBit1: " + geoHashBit1);
		GeoHash geoHashBit2 = GeoHash.withBitPrecision(39.909604, 116.397228, 10);
		// geoHashBit2: 1110011101000000000000000000000000000000000000000000000000000000 ->
		// (45.0,112.5) -> (39.375,123.75) -> wx
		System.out.println("geoHashBit2: " + geoHashBit2);
}
```

## 5.2 获取GeoHash各项属性

​		获取GeoHash的GeoHash字符串、GeoHash的精度、GeoHash临近8个GeoHash、东西南北四个方向GeoHash。

```java
/**
 * 获取GeoHash属性：
 * 获取GeoHash的GeoHash字符串、GeoHash的精度、GeoHash临近8个GeoHash、东西南北四个方向GeoHash
 */
@Test
public void testGeoHashProperty() {
		/************** 获取GeoHash的属性-GeoHash字符串、GeoHash精度 ******************/
		GeoHash geoHash7 = GeoHash.fromGeohashString("wx4g09m");
		// toBase32()：获取指定GeoHash的Base32字符串，要求GeoHash的位的精度必须是5的倍数，否则抛出异常：
		// Cannot convert a geohash to base32 if the precision is not a multiple of 5.
		//        String geoHashStr = geoHashBit1.toBase32();
		String geoHashStr = geoHash7.toBase32();
		// geoHashStr：wx4g09m
		System.out.println("geoHash7Str：" + geoHashStr);

		int characterPrecision = geoHash7.getCharacterPrecision();
		System.out.println("characterPrecision：" + characterPrecision);

		/************ 获取GeoHash的属性-GeoHash临近8个GeoHash、东西南北方向4个GeoHash ************/
		// 获取指定GeoHash网格临近的8个GeoHash，顺序分别是：N, NE, E, SE, S, SW, W, NW
		GeoHash[] adjacent = geoHash7.getAdjacent();
		System.out.println(Arrays.toString(adjacent));

		// getEasternNeighbour()：获取指定GeoHash东边相邻的GeoHash
		GeoHash easternNeighbour = geoHash7.getEasternNeighbour();
		System.out.println("easternNeighbour：" + easternNeighbour);
		// getWesternNeighbour()：获取指定GeoHash西边相邻的GeoHash
		GeoHash westernNeighbour = geoHash7.getWesternNeighbour();
		System.out.println("westernNeighbour：" + westernNeighbour);
		// getNorthernNeighbour()：获取指定GeoHash北边相邻的GeoHash
    GeoHash northernNeighbour = geoHash7.getNorthernNeighbour();
		System.out.println("northernNeighbour：" + northernNeighbour);
		// getSouthernNeighbour()：获取指定GeoHash南边相邻的GeoHash
		GeoHash southernNeighbour = geoHash7.getSouthernNeighbour();
		System.out.println("southernNeighbour：" + southernNeighbour);


		/**************** 获取GeoHash的属性-GeoHash中心点、GeoHash四角各点坐标 ****************/
		// getPoint()：获取构建GeoHash时使用的经纬度，如果使用Base32字符串构建GeoHash则返回中心点
		WGS84Point wgs84Point = geoHash7.getPoint();
		// wgs84Point：(39.90989685058594,116.39671325683594)
		System.out.println("wgs84Point：" + wgs84Point);

		// getBoundingBox()：获取GeoHash的边界框BoundingBox（分隔的网格或者经过指定切分次数后点所在的网格）
		BoundingBox boundingBox = geoHash7.getBoundingBox();
		// getLowerRight()：获取由minLat, maxLon组成的BoundingBox的右侧纬度最小的点（右下角）
		WGS84Point lowerRight = boundingBox.getLowerRight();
		// lowerRight：(39.909210205078125,116.39739990234375)
		System.out.println("lowerRight：" + lowerRight);
		// getUpperLeft()：获取由maxLat, minLon组成的BoundingBox的左侧纬度最高的点（左上角）
		WGS84Point upperLeft = boundingBox.getUpperLeft();
		// upperLeft：(39.91058349609375,116.39602661132812)
		System.out.println("upperLeft：" + upperLeft);
		// getCenterPoint()：获取指定边界框BoundingBox的中心的点的经纬度
		WGS84Point centerPoint = boundingBox.getCenterPoint();
		// centerPoint：(39.90989685058594,116.39671325683594)
		System.out.println("centerPoint：" + centerPoint);
		// 获取指定边界框BoundingBox的最小最大经纬度
		double minLon = boundingBox.getMinLon();
		double minLat = boundingBox.getMinLat();
		double maxLon = boundingBox.getMaxLon();
		double maxLat = boundingBox.getMaxLat();
		double latitudeSize = boundingBox.getLatitudeSize();
		double longitudeSize = boundingBox.getLongitudeSize();
}
```



